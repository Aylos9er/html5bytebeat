<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>HTML5 Bytebeat</title>
<script type="text/javascript" src="tdl/base.js"></script>
<style>
html, body {
    width: 100%;
    height: 100%;
    padding: 0px;
    border: 0px;
    overflow: hidden;
}
#background {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
}
#foreground {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    z-index: 2;
}
#visualization {
    width: 100%;
    height: 100%;
    background-color: rgb(0, 0, 66);
}
#code {
    position: absolute;

    padding: 12px;

    border: none;
    border-radius: 5px;

    color: #ffffff;
    background-color: transparent;
    font-family: Monospace;
    font-size: 14px;
    font-weight: bold;
    text-shadow: rgba( 0, 0, 0, 1 ) 0px 1px 2px;

    white-space: pre;
}

#code:hover {
    background-color:rgba(0, 0, 0, 0.5);
}

textarea:focus {
    outline: 0; /* this removes browser-side outline */
}
</style>
<script>
tdl.require('tdl.buffers');
tdl.require('tdl.fast');
tdl.require('tdl.models');
tdl.require('tdl.primitives');
tdl.require('tdl.programs');
tdl.require('tdl.textures');
tdl.require('tdl.webgl');

window.addEventListener('load', main);

function $(id) {
  return document.getElementById(id);
}

var b;
var gl;
var ctx;
var playing = true;
var play;
var code;
var canvas;
var requestId;

function log(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
}

function main() {
  canvas = $("visualization");
  play = $("play");

  b = new ByteBeat();

  if (!b.good) {
    alert("This page needs a browser the supports the Web Audio API: Chrome, Safari, Chromium or WebKit");
  }

  gl = tdl.webgl.setupWebGL(canvas, {alpha:false, antialias:false}, function(){});
  v = gl ? new WebGLVisualizer() : new CanvasVisualizer();

  play.addEventListener('click', playPause);

  code = $("code");
  code.addEventListener('keyup', function(event) {
    if (event.keyCode == 37 ||
        event.keyCode == 38 ||
        event.keyCode == 39 ||
        event.keyCode == 40) {
      return;
    }

    compile();
  }, false );

  code.addEventListener('keydown', function(event) {
      if (event.keyCode == 9) {
          // Fake TAB
          event.preventDefault();

          var start = code.selectionStart;
          var end = code.selectionEnd;

          code.value = code.value.substring(0, start) + '\t' + code.value.substring(end, code.value.length);

          code.selectionStart = code.selectionEnd = start + 1;
          code.focus();
      }
  }, false);

  compile();

  onWindowResize();
  window.addEventListener('resize', onWindowResize, false);
  b.play();

  function render() {
    if (playing) {
      v.render();
    }
    requestId = tdl.webgl.requestAnimationFrame(render, canvas);
  }
  render();
}

function onWindowResize(event) {
  code.style.top = '75px';
  code.style.left = '25px';
  code.style.width = ( window.innerWidth - 75 ) + 'px';
  code.style.height = ( window.innerHeight - 125 ) + 'px';

  v.resize(canvas.clientWidth, canvas.clientHeight);
}

function compile() {
  if (b.setExpression(code.value)) {
    log("success");
  } else {
    log("fail");
  }
}

function playPause() {
  playing = !playing;
  if (playing) {
    b.play();
    play.value = "pause";
  } else {
    b.pause();
    play.value = "play";
  }
}

ByteBeat = function() {
  var that = this;
  this.buffer = new Float32Array(1024);
  this.desiredSampleRate = 8000;
  this.time = 0;
  this.fn = function() {
    return 0;
  };

  if (window.webkitAudioContext) {
    this.context = new webkitAudioContext();
    this.node = this.context.createJavaScriptNode(1024, 1, 1);
    this.actualSampleRate = this.context.sampleRate;
    this.node.onaudioprocess = function(e) { that.process(e) };
    this.good = true;
  }
};

ByteBeat.prototype.setExpression = function(x) {
  try {
    var c = "temp = {fn: function(t) { return " + x + ";}}";
    var f = eval(c).fn;
  } catch (e) {
    return false;
  }

  try {
    for (var i = 0; i < 1000; i += 100) {
      var s = f(i);
      if (typeof s != "number") {
        return false;
      }
    }
  } catch (e) {
    return false;
  }

  this.fn = f;
  return true;
};

ByteBeat.prototype.convertToDesiredSampleRate = function(rate) {
  return Math.floor(rate * this.desiredSampleRate / this.actualSampleRate);
};

ByteBeat.prototype.process = function(e) {
  var data = e.outputBuffer.getChannelData(0);

  var time = this.convertToDesiredSampleRate(this.time);
  var lastSample = this.convertToDesiredSampleRate(data.length) + 1;
  if (this.buffer.length < lastSample) {
    this.buffer = new Float32Array(lastSample);
  }
  var buffer = this.buffer;
  var fn = this.fn;
  for (var i = 0; i < lastSample; ++i) {
    buffer[i] = fn(time++);
  }
  var dataLength = data.length;
  for (var i = 0; i < dataLength; ++i) {
    data[i] = buffer[this.convertToDesiredSampleRate(i)];
  }

  v.update(buffer, lastSample);

  this.time += dataLength;
};

ByteBeat.prototype.play = function() {
  if (this.node) {
    this.node.connect(this.context.destination);
  }
};

ByteBeat.prototype.pause = function() {
  if (this.node) {
    this.node.disconnect();
  }
};

WebGLVisualizer = function() {
  this.temp = new Float32Array(1);
  this.uniforms = {
    position: 0
  };
  this.resize(512, 512);
};

WebGLVisualizer.prototype.resize = function(width, height) {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
  var height = new tdl.primitives.AttribBuffer(1, width);
  var column = new tdl.primitives.AttribBuffer(1, width);
  var arrays = {
    height: height,
    column: column
  }
  for (var ii = 0; ii < width; ++ii) {
    height.setElement(ii, [Math.sin(ii / width * Math.PI * 2)]);
    column.setElement(ii, [ii / width]);
  }
  if (!this.model) {
    var program = tdl.programs.loadProgramFromScriptTags(
        'vertexShader',
        'fragmentShader');
    this.model = new tdl.models.Model(program, arrays, {}, gl.LINE_STRIP/*gl.POINTS*/);
  } else {
    this.model.setBuffers(arrays, true);
  }
  this.width = width;
  this.height = height;
  this.position = 0;
};

WebGLVisualizer.prototype.update = function(buffer, length) {
  // Yes I know this is dumb. I should just do the last 2 at most.
  while (length) {
    var max = Math.min(length, this.width - this.position);
    var view = new Float32Array(buffer.buffer, 0, max);
    this.model.buffers.height.setRange(view, this.position * 4);
    this.position = (this.position + max) % this.width;
    length -= max;
  }
};

WebGLVisualizer.prototype.render = function() {
  gl.clearColor(0,0,0.3,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  var model = this.model;
  //this.uniforms.position = this.position / this.width;
  model.drawPrep(this.uniforms);
  model.draw();
};

CanvasVisualizer = function() {
  this.ctx = canvas.getContext("2d");
  this.temp = new Float32Array(1);
  this.resize(512, 512);
};

CanvasVisualizer.prototype.resize = function(width, height) {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  this.positions = new Float32Array(width);
  this.oldPositions = new Float32Array(width);
  this.width = width;
  this.height = height;
  this.position = 0;
  this.drawPosition = 0;
  this.drawCount = 0;
};

CanvasVisualizer.prototype.update = function(buffer, length) {
  // Yes I know this is dumb. I should just do the last 2 at most.
  var s = 0;
  var p = this.position;
  var ps = this.positions;
  while (length) {
    var max = Math.min(length, this.width - p);
    for (var i = 0; i < max; ++i) {
      ps[p++] = buffer[s++];
    }
    p = p % this.width;
    this.drawCount += max;
    length -= max;
  }
  this.position = p;
};

CanvasVisualizer.prototype.render = function() {
  var count = Math.min(this.drawCount, this.width);
  var dp = this.drawPosition;
  var ctx = this.ctx;
  var old = this.oldPositions;
  var ps = this.positions;
  var halfHeight = this.height / 2;
  ctx.fillStyle = "rgb(255,0,0)";
  while (count) {
    ctx.clearRect(dp, old[dp], 1, 1);
    var newPos = Math.floor(-ps[dp] * halfHeight + halfHeight);
    ctx.fillRect(dp, newPos, 1, 1);
    old[dp] = newPos;
    dp = (dp + 1) % this.width;
    --count;
  }
  this.drawCount = 0;
  this.drawPosition = dp;
};
</script>
</head>
<body>
<div id="background">
  <canvas id="visualization"></cavnas>
</div>
<div id="foreground">
<div id="controls">
  <input type="button" id="play" value="pause"/>
</div>
<textarea id="code">((((t >> 10) & 42) * t) & 255) / 127 - 1</textarea>
</div>
<script id="vertexShader" type="not-js">
attribute float column;
attribute float height;
uniform float position;
void main() {
  gl_Position = vec4(mod(column - position, 1.0) * 2.0 - 1.0, height, 0, 1);
}
</script>
<script id="fragmentShader" type="not-js">
precision mediump float;
void main() {
  gl_FragColor = vec4(1,0,0,1);
}
</script>
</body>
</html>
