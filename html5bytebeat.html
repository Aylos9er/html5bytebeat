<!--
 * Copyright 2012, Gregg Tavares.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Gregg Tavares. nor the names of his
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>HTML5 Bytebeat</title>
<script src="js/lzma.js"></script>
<script type="text/javascript" src="tdl/base.js"></script>
<style>
html, body {
    width: 100%;
    height: 100%;
    padding: 0px;
    border: 0px;
    overflow: hidden;
    font-family: Monospace;
}
a:link, a:visited, a:hover, a:active {
  color: white;
  text-decoration: none;
}
#background {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
}
#foreground {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
    z-index: 2;
}
#visualization {
    width: 100%;
    height: 100%;
    background-color: rgb(0, 0, 66);
}
#controls {
    position: absolute;
    left: 25px;
    top: 25px;
}
#code {
    position: absolute;
    left: 25px;

    padding: 12px;

    border: none;
    border-radius: 5px;

    color: #ffffff;
    background-color: transparent;
    font-family: Monospace;
    font-size: 14px;
    font-weight: bold;
    text-shadow: rgba( 0, 0, 0, 1 ) 0px 1px 2px;

    white-space: pre;
}

#code:hover {
    background-color:rgba(0, 0, 0, 0.5);
}

textarea:focus {
    outline: 0; /* this removes browser-side outline */
}

button, select, .buttonstyle {
    padding: 8px 12px 8px 12px;
    border: none;
    border-radius: 5px;
    margin-right: 5px;
    color: #ffffff;
    background-color: #000000;
    opacity: 0.5;
    font-family: Monospace;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
}
button:hover, select:hover, .buttonstyle:select {
    opacity: 1;
}
option {
    color: #ffffff;
    background-color: #000000;
}
</style>
<script>
tdl.require('tdl.buffers');
tdl.require('tdl.fast');
tdl.require('tdl.models');
tdl.require('tdl.primitives');
tdl.require('tdl.programs');
tdl.require('tdl.textures');
tdl.require('tdl.webgl');

window.addEventListener('load', main);

function $(id) {
  return document.getElementById(id);
}

var g_byteBeat;
var g_visualizer;
var gl;
var playing = false;
var play;
var codeElem;
var canvas;
var requestId;
var compressor;
var dontSet = true;

function log(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
}

function main() {
  compressor = new LZMA( "js/lzma_worker.js" );
  canvas = $("visualization");
  controls = $("controls");

  g_byteBeat = new ByteBeat();
  if (!g_byteBeat.good) {
    alert("This page needs a browser the supports the Web Audio API or the Audio Data API: Chrome, Chromium, Firefox, or WebKit");
  }

  function resetToZero() {
    g_byteBeat.reset();
    g_visualizer.reset();
    g_visualizer.render();
    updateTimeDisplay();
  }

  helpElem = document.createElement('a');
  helpElem.href = "https://github.com/greggman/html5bytebeat";
  helpElem.innerHTML = "?";
  helpElem.className = "buttonstyle";
  controls.appendChild(helpElem);

  timeElem = document.createElement('button');
  controls.appendChild(timeElem);
  timeElem.addEventListener('click', resetToZero);

  function playPause() {
    playing = !playing;
    if (playing) {
      g_byteBeat.play();
      playElem.textContent = "pause ■";
    } else {
      g_byteBeat.pause();
      playElem.textContent = " play ▶";
      updateTimeDisplay();
    }
  }
  playElem = document.createElement('button');
  playElem.addEventListener('click', playPause);
  controls.appendChild(playElem);

  function addSelection(options, selectedIndex) {
    var select = document.createElement('select');
    for (var i = 0; i < options.length; ++i) {
      option = document.createElement('option');
      option.textContent = options[i];
      if (i == selectedIndex) {
        option.selected = true;
      }
      select.appendChild(option);
    }
    return select;
  }

  beatTypeElem = addSelection(["bytebeat", "floatbeat"], 0);
  beatTypeElem.addEventListener('change', function(event) {
    g_byteBeat.setType(event.target.selectedIndex);
    setURL();
  }, false);
  controls.appendChild(beatTypeElem);

  //expressionTypeElem = addSelection(["infix", "postfix(rpn)", "glitch"], 0);
  expressionTypeElem = addSelection(["infix", "postfix(rpn)"], 0);
  expressionTypeElem.addEventListener('change', function(event) {
    g_byteBeat.setExpressionType(event.target.selectedIndex);
    g_byteBeat.recompile();
  }, false);
  controls.appendChild(expressionTypeElem);

  var sampleRates = [8000, 11000, 22000, 32000, 44100];
  sampleRateElem = addSelection(["8kHz", "11kHz", "22kHz", "32kHz", "44kHz"], 0);
  sampleRateElem.addEventListener('change', function(event) {
    g_byteBeat.setDesiredSampleRate(sampleRates[event.target.selectedIndex]);
  }, false);
  controls.appendChild(sampleRateElem);

  visualTypeElem = addSelection(["none", "wave"], 1);
  visualTypeElem.addEventListener('change', function(event) {
    g_visualizer.setType(event.target.selectedIndex);
  }, false);
  controls.appendChild(visualTypeElem);

  compileStatusElem = document.createElement('button');
  compileStatusElem.textContent = "---";
  controls.appendChild(compileStatusElem);

  gl = tdl.webgl.setupWebGL(canvas, {alpha:false, antialias:false}, function(){});
  g_visualizer = gl ? new WebGLVisualizer() : new CanvasVisualizer();
  g_byteBeat.setVisualizer(g_visualizer);

  codeElem = $("code");
  codeElem.addEventListener('keyup', function(event) {
    if (event.keyCode == 37 ||
        event.keyCode == 38 ||
        event.keyCode == 39 ||
        event.keyCode == 40) {
      return;
    }

    compile(codeElem.value);
  }, false );

  codeElem.addEventListener('keydown', function(event) {
      if (event.keyCode == 9) {
          // Fake TAB
          event.preventDefault();

          var start = codeElem.selectionStart;
          var end = codeElem.selectionEnd;

          codeElem.value = codeElem.value.substring(0, start) + '\t' + codeElem.value.substring(end, codeElem.value.length);

          codeElem.selectionStart = codeElem.selectionEnd = start + 1;
          codeElem.focus();
      }
  }, false);

  g_byteBeat.setOnCompile(handleCompileError);
  g_visualizer.setOnCompile(handleCompileError);

  if (window.location.hash) {
    var hash = window.location.hash.substr(1);
    readURL(hash);
  } else {
    readURL('t=0&e=0&s=8000&bb=5d000001001400000000000000001461cc403ebd1b3df4f78ee66fe76abfec87b7777fd27ffff85bd000');
  }

  onWindowResize();
  window.addEventListener('resize', onWindowResize, false);
  playPause();

  function render() {
    if (playing) {
      updateTimeDisplay();
      g_visualizer.render();
    }
    requestId = tdl.webgl.requestAnimationFrame(render, canvas);
  }
  render();

  function setSelectOption(select, selectedIndex) {
    select.options[select.selectedIndex].selected = false;
    select.options[selectedIndex].selected = true;
  }

  function readURL(hash) {
    var args = hash.split("&");
    var data = {};
    for (var i = 0; i < args.length; ++i) {
      var parts = args[i].split("=");
      data[parts[0]] = parts[1];
    }
    var t = data.t !== undefined ? data.t : 1
    var e = data.e !== undefined ? data.e : 0;
    var s = data.s !== undefined ? data.s : 8000;
    for (var i = 0; i < sampleRates.length; ++i) {
      if (s == sampleRates[i]) {
        setSelectOption(sampleRateElem, i);
        break;
      }
    }
    setSelectOption(beatTypeElem, t);
    setSelectOption(expressionTypeElem, e);
    g_byteBeat.setType(parseInt(t));
    g_byteBeat.setExpressionType(parseInt(e));
    g_byteBeat.setDesiredSampleRate(parseInt(s));
    var bytes = convertHexToBytes(data.bb);
    compressor.decompress(bytes, function(text) {
      codeElem.value = text;
      compile(text);
    },
    dummyFunction);
  }

  function onWindowResize(event) {
    codeElem.style.top = '75px';
    codeElem.style.width = ( window.innerWidth - 75 ) + 'px';
    codeElem.style.height = ( window.innerHeight - 125 ) + 'px';

    g_byteBeat.resize(canvas.clientWidth, canvas.clientHeight);
    g_visualizer.resize(canvas.clientWidth, canvas.clientHeight);
  }
}

function dummyFunction() {};

function updateTimeDisplay() {
  timeElem.innerHTML = g_byteBeat.getTime();
};

// Splits a string, looking for //:name
var g_splitRE = new RegExp(/\/\/\:([a-zA-Z0-9_-]+)(.*)/);
function splitBySections(str) {
  var sections = {};

  function getNextSection(str) {
    var pos = str.search(g_splitRE);
    if (pos < 0) {
      return str;
    }
    var m = str.match(g_splitRE);
    var sectionName = m[1];
    newStr = getNextSection(str.substring(pos + 3 + sectionName.length));
    sections[sectionName] = newStr;
    return str.substring(0, pos);
  }
  str = getNextSection(str);
  if (str.length) {
    sections.default = str;
  }
  return sections;
}
function compile(text) {
  var sections = splitBySections(text);
  if (sections.default || sections.channel1) {
    var expressions = [sections.default || sections.channel1];
    if (sections.channel2) {
      expressions.push(sections.channel2);
    }
    g_byteBeat.setExpressions(expressions);
  }
  // comment in to allow live GLSL editing
  //g_visualizer.setEffects(sections);
}

function handleCompileError(error) {
  if (error == null) {
    compileStatusElem.textContent = "compiled successfully";
    compileStatusElem.style.color = "#0F0";
    setURL();
  } else {
    compileStatusElem.textContent = error;
    compileStatusElem.style.color = "#F00";
  }
}

function convertHexToBytes(text) {
  var array = [];
  for (var i = 0; i < text.length; i += 2) {
    var tmpHex = text.substring(i, i + 2);
    array.push(parseInt(tmpHex, 16));
  }
  return array;
}

function convertBytesToHex(byteArray) {
  var hex = "";
  for (var i = 0, il = byteArray.length; i < il; i++) {
    if (byteArray[i] < 0) {
      byteArray[i] = byteArray[i] + 256;
    }
    var tmpHex = byteArray[i].toString(16);
    // add leading zero
    if (tmpHex.length == 1) {
      tmpHex = "0" + tmpHex;
    }
    hex += tmpHex;
  }
  return hex;
}

function setURL() {
  if (dontSet) {
    dontSet = false;
    return;
  }
  compressor.compress(codeElem.value, 1, function(bytes) {
    var hex = convertBytesToHex(bytes);
    window.location.replace(
      '#t=' + g_byteBeat.getType() +
      '&e=' + g_byteBeat.getExpressionType() +
      '&s=' + g_byteBeat.getDesiredSampleRate() +
      '&bb=' + hex);
  },
  dummyFunction);
}

ByteBeat = function() {
  var that = this;
  this.buffer0 = new Float32Array(4096);
  this.buffer1 = new Float32Array(4096);
  this.desiredSampleRate = 8000;
  this.time = 0;
  this.dataTime = 0;
  this.floatBeat = false;
  this.expressionType = 0;
  this.functions = [function(t) {
    return Math.sin(t) * 0.1;
  }]
  this.expressions = ["Math.sin(t) * 0.1"];
  this.extra = {
    mouseX: 0,
    mouseY: 0,
    width: 1,
    height: 1
  };

  window.addEventListener('mousemove', function(event) {
    var extra = that.extra;
    extra.mouseX = event.clientX;
    extra.mouseY = event.clientY;
  }, true);

  if (window.webkitAudioContext) {
    this.context = new webkitAudioContext();
    this.node = this.context.createJavaScriptNode(4096, 2, 2);
    this.actualSampleRate = this.context.sampleRate;
    this.node.onaudioprocess = function(e) {
      var data = e.outputBuffer.getChannelData(0);
      that.process(data.length, data,
                   e.outputBuffer.getChannelData(1));
    };
    this.good = true;
  } else {
    var audio = new Audio()
    this.audio = audio;
    if (!audio.mozSetup) {
      return;
    }
    this.good = true;

    function AudioDataDestination(sampleRate, readFn) {
      // Initialize the audio output.
      var audio = new Audio();
      var channels = 2
      audio.mozSetup(channels, sampleRate);

      var currentWritePosition = 0;
      var prebufferSize = sampleRate * channels / 2; // buffer 500ms
      var tail = null, tailPosition;

      // The function called with regular interval to populate
      // the audio output buffer.
      setInterval(function() {
        var written;
        // Check if some data was not written in previous attempts.
        if(tail) {
          written = audio.mozWriteAudio(tail.subarray(tailPosition));
          currentWritePosition += written;
          tailPosition += written;
          if(tailPosition < tail.length) {
            // Not all the data was written, saving the tail...
            return; // ... and exit the function.
          }
          tail = null;
        }

        // Check if we need add some data to the audio output.
        var currentPosition = audio.mozCurrentSampleOffset();
        var available = currentPosition + prebufferSize - currentWritePosition;
        if(available > 0) {
          // Request some sound data from the callback function.
          var soundData = new Float32Array(available);
          readFn(soundData);

          // Writting the data.
          written = audio.mozWriteAudio(soundData);
          if(written < soundData.length) {
            // Not all the data was written, saving the tail.
            tail = soundData;
            tailPosition = written;
          }
          currentWritePosition += written;
        }
      }, 100);
    }

    this.actualSampleRate = 44100;//this.desiredSampleRate;
    var audioDestination = new AudioDataDestination(this.actualSampleRate, function(buffer) {
      if (playing) {
        that.process(buffer.length >> 1, buffer);
      }
    });
  }
};

function strip(s) {
  return s.replace(/^\s+/,"").replace(/\s+$/,"");
}

ByteBeat.prototype.resize = function(width, height) {
  this.extra.width = width;
  this.extra.height = height;
};

ByteBeat.prototype.setVisualizer = function(visualizer) {
  this.visualizer = visualizer;
};

ByteBeat.prototype.reset = function() {
  this.time = 0;
  this.dataTime = 0;
};

ByteBeat.prototype.getTime = function() {
  return this.convertToDesiredSampleRate(this.time);
};

var g_glitchToPostfix = {
    'a': 't',
    'c': 'drop',

    'd': '*',
    'e': '/',
    'f': '+',
    'g': '-',
    'h': '%',

    'j': '<<',
    'k': '>>',
    'l': '&',
    'm': '|',
    'n': '^',
    'o': '~',

    'p': 'dup',
    'q': 'pick',
    'r': 'swap',

    's': '<',
    't': '>',
    'u': '=',
    '/': '//',
};

ByteBeat.prototype.setOnCompile = function(callback) {
  this.onCompileCallback = callback;
};

ByteBeat.prototype.recompile = function() {
  this.setExpressions(this.getExpressions());
};

ByteBeat.prototype.setExpressions = function(expressions) {
  function removeCommentsAndLineBreaks(x) {
    // remove comments (hacky)
    x = x.replace(/\/\/.*/g, " ");
    x = x.replace(/\n/g, " ");
    x = x.replace(/\/\*.*?\*\//g, " ");
    return x;
  }

  function compileExpression(x, expressionType, extra, window) {
    if (expressionType == 2) { // glitch
      // Convert to postfix
      var postfix = [];
      for (var i = 0; i < x.length; ++i) {
        var c = x[i];
        postfix.push(g_glitchToPostfix[c] || c);
      }
      x = postfix.join(" ");
      expressionType = 1;
    }
    if (expressionType == 1) {  // postfix
      x = removeCommentsAndLineBreaks(x);
      // compress space
      x = x.replace(/(\r\n|\r|\n|\t| )+/gm, " ");
      var tokens = strip(x).split(" ");
      var stack = [];
      for (var i = 0; i < tokens.length; ++i) {
        var token = tokens[i];
        switch (token.toLowerCase()) {
        case '>':
          var v1 = stack.pop();
          var v2 = stack.pop();
          stack.push("((" + v2 + " < " + v1 + ") ? 0xFFFFFFFF : 0)");
          break;
        case '<':
          var v1 = stack.pop();
          var v2 = stack.pop();
          stack.push("((" + v2 + " > " + v1 + ") ? 0xFFFFFFFF : 0)");
          break;
        case '=':
          var v1 = stack.pop();
          var v2 = stack.pop();
          stack.push("((" + v2 + " == " + v1 + ") ? 0xFFFFFFFF : 0)");
          break;
        case 'drop':
          stack.pop();
          break;
        case 'dup':
          var a0 = stack.pop();
          stack.push(a0);
          stack.push(a0);
          break;
        case 'swap':
          var a1 = stack.pop();
          var a0 = stack.pop();
          stack.push(a1);
          stack.push(a0);
          break;
        case 'pick':
          throw ('not implemented');
          break;
        case 'abs':
        case 'sqrt':
        case 'round':
        case 'tan':
        case 'log':
        case 'exp':
        case 'sin':
        case 'cos':
        case 'tan':
        case 'floor':
        case 'ceil':
        case 'int':
          var a0 = stack.pop();
          stack.push(token + "(" + a0 + ")");
          break;
        case 'max':
        case 'min':
        case 'pow':
          var a0 = stack.pop();
          var a1 = stack.pop();
          stack.push(token + "(" + a1 + "," + a0 + ")");
          break;
        case 'random':
          stack.push(token + "()");
          break;
        case '+':
        case '-':
        case '*':
        case '/':
        case '%':
        case '>>':
        case '<<':
        case '|':
        case '&':
        case '^':
        case '&&':
        case '||':
          var a1 = stack.pop();
          var a0 = stack.pop();
          stack.push("(" + a0 + token + a1 + ")");
          break;
        default:
          stack.push(token);
          break;
        }
      }
      x = stack.pop();
    }
    x = removeCommentsAndLineBreaks(x);
    // Translate a few things.
    function replacer(str, obj, p1, name) {
      return obj.hasOwnProperty(p1) ? (name + p1) : str;
    }

    x = x.replace(/(?:Math\.)?(\w+)/g, function(substr, p1) {
      return replacer(substr, Math, p1, "Math.");
    });
    x = x.replace(/(?:extra\.)?(\w+)/g, function(substr, p1) {
      return replacer(substr, extra, p1, "extra.");
    });

    var c = "temp = {fn: function(t) { return " + strip(x) + ";}}";
    var f = eval(c).fn;

    for (var i = 0; i < 1000; i += 100) {
      var s = f(i);
      if (typeof s != "number") {
        throw "NaN";
      }
    }

    return f;
  }

  var funcs = [];
  try {
    for (var i = 0; i < expressions.length; ++i) {
      var exp = expressions[i];
      if (exp != this.expressions[i]) {
        funcs.push(compileExpression(exp, this.expressionType, this.extra));
      } else {
        if (this.functions[i]) {
          funcs.push(this.functions[i]);
        }
      }
    }
  } catch(e) {
    if (this.onCompileCallback) {
      this.onCompileCallback(e.toString());
    }
    return;
  }

  // copy the expressions
  this.expressions = expressions.slice(0);
  this.functions = funcs;
  if (this.onCompileCallback) {
    this.onCompileCallback(null);
  }
};

ByteBeat.prototype.convertToDesiredSampleRate = function(rate) {
  return Math.floor(rate * this.desiredSampleRate / this.actualSampleRate);
};

ByteBeat.prototype.setDesiredSampleRate = function(rate) {
  this.desiredSampleRate = rate;
};

ByteBeat.prototype.getDesiredSampleRate = function() {
  return this.desiredSampleRate;
};

ByteBeat.prototype.setExpressionType = function(type) {
  this.expressionType = type;
};

ByteBeat.prototype.getExpressions = function() {
  return this.expressions.slice(0);
};

ByteBeat.prototype.getExpressionType = function() {
  return this.expressionType;
};

ByteBeat.prototype.setType = function(floatBeat) {
  this.floatBeat = floatBeat;
};

ByteBeat.prototype.getType = function() {
  return this.floatBeat;
};

ByteBeat.prototype.process = function(dataLength, leftData, rightData) {
  var time = this.convertToDesiredSampleRate(this.time);
  var lastSample = this.convertToDesiredSampleRate(dataLength) + 2;
  if (this.buffer0.length < lastSample) {
    this.buffer0 = new Float32Array(lastSample);
    this.buffer1 = new Float32Array(lastSample);
  }
  var buffer0 = this.buffer0;
  var buffer1;
  //
  var fn0 = this.functions[0];
  var fn1 = this.functions[1];
  if (fn1) {
    buffer1 = this.buffer1;
    if (this.floatBeat) {
      for (var i = 0; i < lastSample; ++i) {
        buffer0[i] = fn0(time  );
        buffer1[i] = fn1(time++);
      }
    } else {
      for (var i = 0; i < lastSample; ++i) {
        buffer0[i] = (fn0(time  ) & 255) / 127 - 1;
        buffer1[i] = (fn1(time++) & 255) / 127 - 1;
      }
    }
  } else {
    buffer1 = this.buffer0;
    if (this.floatBeat) {
      for (var i = 0; i < lastSample; ++i) {
        buffer0[i] = fn0(time++);
      }
    } else {
      for (var i = 0; i < lastSample; ++i) {
        buffer0[i] = (fn0(time++) & 255) / 127 - 1;
      }
    }
  }
  if (rightData) {
    for (var i = 0; i < dataLength; ++i) {
      var ndx = this.convertToDesiredSampleRate(i);
      leftData[i] = buffer0[ndx];
      rightData[i] = buffer1[ndx];
    }
  } else {
    for (var i = 0; i < dataLength; ++i) {
      var ndx = this.convertToDesiredSampleRate(i);
      leftData[i * 2] = buffer0[ndx];
      leftData[i * 2 + 1] = buffer1[ndx];
    }
  }

  if (this.visualizer) {
    this.visualizer.update(buffer0, lastSample - 1);
  }

  this.time += dataLength;
};

ByteBeat.prototype.play = function() {
  if (this.node) {
    this.node.connect(this.context.destination);
  }
};

ByteBeat.prototype.pause = function() {
  if (this.node) {
    this.node.disconnect();
  }
};

WebGLVisualizer = function() {
  this.type = 1;
  this.temp = new Float32Array(1);
  this.resolution = new Float32Array(2);
  this.effects = {
    wave: {
      uniforms: {
        position: 0,
        time: 0,
        resolution: this.resolution
      }
    },
    data: {
      uniforms: {
        offset: 0,
        time: 0,
        resolution: this.resolution
      }
    }
  };

  this.effects.wave[gl.VERTEX_SHADER] = {
    defaultSource: $("waveVertexShader").text
  };
  this.effects.wave[gl.FRAGMENT_SHADER] = {
    defaultSource: $("waveFragmentShader").text
  };
  this.effects.data[gl.VERTEX_SHADER] = {
    defaultSource: $("dataVertexShader").text
  };
  this.effects.data[gl.FRAGMENT_SHADER] = {
    defaultSource: $("dataFragmentShader").text
  };

  this.resize(512, 512);
};

WebGLVisualizer.prototype.resize = function(width, height) {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
  var height = new tdl.primitives.AttribBuffer(1, width * 2);
  var column = new tdl.primitives.AttribBuffer(1, width * 2);
  for (var ii = 0; ii < width * 2; ++ii) {
    height.setElement(ii, [Math.sin(ii / width * Math.PI * 2)]);
    column.setElement(ii, [(ii >> 1) / width]);
  }
  var arrays = {
    height: height,
    column: column
  }
  var effects = this.effects;
  var wave = effects.wave;
  if (!wave.model) {
    var program = tdl.programs.loadProgram(
        wave[gl.VERTEX_SHADER].defaultSource,
        wave[gl.FRAGMENT_SHADER].defaultSource);
    wave.model = new tdl.models.Model(program, arrays, {}, gl.LINES/*gl.LINE_STRIP*/ /*gl.POINTS*/);
  } else {
    wave.model.setBuffers(arrays, true);
  }

  var data = effects.data;
  if (!data.model) {
    var tex = new tdl.textures.ExternalTexture(gl.TEXTURE_2D);
    var arrays = tdl.primitives.createPlane(2, 2, 1, 1);
    // Don't need the normals.
    delete arrays.normal;
    delete arrays.texCoord;
    // rotate from xz plane to xy plane
    tdl.primitives.reorient(arrays,
        [1, 0, 0, 0,
         0, 0, 1, 0,
         0, -1, 0, 0,
         0, 0, 0, 1]);
    var textures = {
        tex: tex,
    };
    var program = tdl.programs.loadProgram(
        data[gl.VERTEX_SHADER].defaultSource,
        data[gl.FRAGMENT_SHADER].defaultSource);
    data.model = new tdl.models.Model(program, arrays, textures);
    this.dataTex = tex;
  }

  this.dataWidth = 1024;
  var sampleBuf = new Uint8Array(this.dataWidth);
  this.dataPos = 0;
  this.dataPixel = new Uint8Array(1);
  this.dataTex.setParameter(gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  this.dataTex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.LUMINANCE, this.dataWidth, 1, 0,
      gl.LUMINANCE, gl.UNSIGNED_BYTE, sampleBuf);
  this.dataBuf = sampleBuf;

  this.oneVerticalPixel = 2 / canvas.height;
  this.width = width;
  this.height = height;
  this.position = 0;
  this.then = (new Date()).getTime() * 0.001;
  this.compiling = false;
};

WebGLVisualizer.prototype.reset = function() {
  this.then = (new Date()).getTime() * 0.001;
  for (var i = 0; i < this.height.numElements; ++i) {
    this.height.setElement(i, [0]);
  }
  this.position = 0;
  this.effects.wave.model.buffers.height.set(this.height);
  this.dataPos = 0;
  for (var i = 0; i < this.dataWidth; ++i) {
    this.dataBuf[i] = 0;
  }
  this.dataTex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.LUMINANCE, this.dataWidth, 1, 0,
      gl.LUMINANCE, gl.UNSIGNED_BYTE, this.dataBuf);
};

WebGLVisualizer.prototype.setType = function(type) {
  this.type = type;
};

WebGLVisualizer.prototype.setOnCompile = function(callback) {
  this.onCompileCallback = callback;
};

WebGLVisualizer.prototype.setShaderGLSL = function(effect, vertexShaderSource, fragmentShaderSource) {
  if (!vertexShaderSource) {
    vertexShaderSource = effect[gl.VERTEX_SHADER].defaultSource;
  }
  if (!fragmentShaderSource) {
    fragmentShaderSource = effect[gl.FRAGMENT_SHADER].defaultSource;
  }

  effect[gl.VERTEX_SHADER].pending = vertexShaderSource;
  effect[gl.FRAGMENT_SHADER].pending = fragmentShaderSource;
}

WebGLVisualizer.prototype.compileIfPending = function() {
  if (this.compiling) {
    return;
  }

  if (this.compileShaderIfPending(this.effects.wave)) {
    return;
  }

  if (this.compileShaderIfPending(this.effects.data)) {
    return;
  }
};

WebGLVisualizer.prototype.compileShaderIfPending = function(effect) {
  var pendingVertexShader = effect[gl.VERTEX_SHADER].pending;
  var pendingFragmentShader = effect[gl.FRAGMENT_SHADER].pending;

  // If there was nothing pending exit
  if (pendingVertexShader === undefined && pendingFragmentShader === undefined) {
    return false;
  }

  // clear pending
  effect[gl.VERTEX_SHADER].pending = undefined;
  effect[gl.FRAGMENT_SHADER].pending = undefined;

  // If there was no change exit.
  if (pendingVertexShader == effect[gl.VERTEX_SHADER].source &&
      pendingFragmentShader == effect[gl.FRAGMENT_SHADER].source) {
    //this.onCompileCallback(null);
    return false;
  }

  this.compiling = true;
  var that = this;
  this.programBeingCompiled = tdl.programs.loadProgram(pendingVertexShader, pendingFragmentShader, function(error) {
    that.handleCompile(error, effect, pendingVertexShader, pendingFragmentShader);
  });
  return true;
};

WebGLVisualizer.prototype.handleCompile = function(error, effect, vertexShaderSource, fragmentShaderSource) {
  this.compiling = false;
  if (error !== undefined) {
    if (this.onCompileCallback) {
      this.onCompileCallback(tdl.programs.lastError);
    }
  } else {
    effect.model.setProgram(this.programBeingCompiled);
    effect[gl.VERTEX_SHADER].source = vertexShaderSource;
    effect[gl.FRAGMENT_SHADER].source = fragmentShaderSource;
    if (this.onCompileCallback) {
      this.onCompileCallback(null);
    }
  }
  this.compileIfPending();
};

WebGLVisualizer.prototype.setEffects = function(sections) {
  this.setShaderGLSL(this.effects.wave, sections['glsl-wave-vs'], sections['glsl-wave-fs']);
  this.setShaderGLSL(this.effects.data, this.effects.data[gl.VERTEX_SHADER].defaultSource, sections['glsl-data-fs']);
  this.compileIfPending();
};

WebGLVisualizer.prototype.update = function(buffer, length) {
  if (!this.type) {
    return;
  }
  // Yes I know this is dumb. I should just do the last 2 at most.
  var dest = this.height.buffer;
  var offset = 0;
  var v = this.oneVerticalPixel;
  var v2 = v * 2;
  while (length) {
    var max = Math.min(length, this.width - this.position);
    var d = this.position * 2;
    var h1 = buffer[offset];
    for (i = 0; i < max; ++i) {
      var h2 = buffer[++offset];
      var dy = h1 - h2;
      dest[d++] = h1;
      dest[d++] = Math.abs(dy) > v ? h2 : (h2 + (dy > 0 ? v2 : -v2));
      h1 = h2;
    }
    var view = new Float32Array(dest.buffer, this.position * 4 * 2, max * 2);
    this.effects.wave.model.buffers.height.setRange(view, this.position * 4 * 2);
    this.position = (this.position + max) % this.width;
    length -= max;
  }
};

WebGLVisualizer.prototype.render = function() {
  if (!this.type) {
    return;
  }

  gl.clearColor(0,0,0.3,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  var effects = this.effects;
  var wave = this.effects.wave;
  var data = this.effects.data;

  this.resolution[0] = canvas.width;
  this.resolution[1] = canvas.height;

  this.dataTex.setParameter(gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  this.dataPixel[0] = g_byteBeat.functions[0](g_byteBeat.dataTime++) * 127 + 127;
  gl.texSubImage2D(gl.TEXTURE_2D, 0, this.dataPos++, 0, 1, 1, gl.LUMINANCE, gl.UNSIGNED_BYTE, this.dataPixel);
  this.dataPos = this.dataPos % this.dataWidth;
  var now = (new Date()).getTime() * 0.001;

  data.uniforms.offset = this.dataPos / this.dataWidth;
  data.uniforms.time = now - this.then;
  data.model.drawPrep(data.uniforms);
  data.model.draw();

  wave.uniforms.position = this.position / this.width;
  wave.uniforms.time = now - this.then;
  wave.model.drawPrep(wave.uniforms);
  wave.model.draw();
};

CanvasVisualizer = function() {
  this.ctx = canvas.getContext("2d");
  this.temp = new Float32Array(1);
  this.resize(512, 512);
  this.type = 1;
};

CanvasVisualizer.prototype.resize = function(width, height) {
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  this.positions = new Float32Array(width);
  this.oldPositions = new Float32Array(width);
  this.width = width;
  this.height = height;
  this.position = 0;
  this.drawPosition = 0;
  this.drawCount = 0;
};

CanvasVisualizer.prototype.reset = function() {
  this.position = 0;
  this.drawPosition = 0;
  this.drawCount = 0;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
};

CanvasVisualizer.prototype.setOnCompile = function(callback) {
  this.onCompileCallback = callback;
};

CanvasVisualizer.prototype.setType = function(type) {
  this.type = type;
};

CanvasVisualizer.prototype.setEffects = function(sections) {
};

CanvasVisualizer.prototype.update = function(buffer, length) {
  if (!this.type) {
    return;
  }
  // Yes I know this is dumb. I should just do the last 2 at most.
  var s = 0;
  var p = this.position;
  var ps = this.positions;
  while (length) {
    var max = Math.min(length, this.width - p);
    for (var i = 0; i < max; ++i) {
      ps[p++] = buffer[s++];
    }
    p = p % this.width;
    this.drawCount += max;
    length -= max;
  }
  this.position = p;
};

CanvasVisualizer.prototype.render = function() {
  if (!this.type) {
    return;
  }
  var count = Math.min(this.drawCount, this.width);
  var dp = this.drawPosition;
  var ctx = this.ctx;
  var old = this.oldPositions;
  var ps = this.positions;
  var halfHeight = this.height / 2;
  ctx.fillStyle = "rgb(255,0,0)";
  /* horizontal */
  while (count) {
    ctx.clearRect(dp, old[dp], 1, 1);
    var newPos = Math.floor(-ps[dp] * halfHeight + halfHeight);
    ctx.fillRect(dp, newPos, 1, 1);
    old[dp] = newPos;
    dp = (dp + 1) % this.width;
    --count;
  }

  /* vertical hack (drawing the wave vertically should be faster */
  /*
  var w = this.width;
  var h = this.height;
  var hw = Math.floor(w * 0.5);
  while (count) {
    var y = Math.floor(dp * h / w);
    var oldX = Math.floor(old[dp] * w / h * 0.3);
    ctx.clearRect(hw - oldX, y, oldX * 2, 1);
    var newPos = Math.floor(-ps[dp] * halfHeight + halfHeight);
    var x = Math.floor(newPos * w / h * 0.3);
    ctx.fillRect(hw - x, y, x * 2, 1, 1);
    old[dp] = newPos;
    dp = (dp + 1) % this.width;
    --count;
  }
  */
  this.drawCount = 0;
  this.drawPosition = dp;
};
</script>
</head>
<body>
<div id="background">
  <canvas id="visualization"></cavnas>
</div>
<div id="foreground">
<div id="controls">
</div>
  <!-- ((((t >> 10) & 42) * t) & 255) / 127 - 1 -->
<textarea id="code"></textarea>
</div>
<script id="waveVertexShader" type="not-js">
attribute float column;
attribute float height;
uniform float position;
void main() {
  gl_Position = vec4(mod(column - position, 1.0) * 2.0 - 1.0, height, 0, 1);
}
</script>
<script id="waveFragmentShader" type="not-js">
precision mediump float;
void main() {
  gl_FragColor = vec4(1,0,0,1);
}
</script>
<script id="dataVertexShader" type="not-js">
attribute vec2 position;
uniform float offset;
varying vec2 v_texCoord;
void main() {
  gl_Position = vec4(position, 0, 1);
  v_texCoord = vec2(position * 0.5 + 0.5) + vec2(offset, 0);
}
</script>
<script id="dataFragmentShader" type="not-js">
precision mediump float;
varying vec2 v_texCoord;
uniform sampler2D tex;
void main() {
  int c = int(texture2D(tex, v_texCoord).r * 255.0);
  int y = int(v_texCoord.y * 8.0);
  int p = int(pow(2.0, float(y)));
  c = c / p;
  float m = mod(float(c), 2.0);
  float line = mod(gl_FragCoord.y, 3.0) / 2.0;
  gl_FragColor = vec4(0, 0, m * line, m);
}
</script>
</body>
</html>
